(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/common'), require('@angular/core'), require('rxjs'), require('rxjs/operators')) :
    typeof define === 'function' && define.amd ? define('@ngx-pwa/local-storage', ['exports', '@angular/common', '@angular/core', 'rxjs', 'rxjs/operators'], factory) :
    (factory((global['ngx-pwa'] = global['ngx-pwa'] || {}, global['ngx-pwa']['local-storage'] = {}),global.ng.common,global.ng.core,global.rxjs,global.rxjs.operators));
}(this, (function (exports,common,i0,rxjs,operators) { 'use strict';

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var LOCAL_STORAGE_PREFIX = new i0.InjectionToken('localStoragePrefix', { providedIn: 'root', factory: function () { return ''; } });
    /**
     * @param {?} config
     * @return {?}
     */
    function localStorageProviders(config) {
        return [
            config.prefix ? { provide: LOCAL_STORAGE_PREFIX, useValue: config.prefix } : []
        ];
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var LocalStorageDatabase = /** @class */ (function () {
        function LocalStorageDatabase(userPrefix) {
            if (userPrefix === void 0) {
                userPrefix = null;
            }
            this.userPrefix = userPrefix;
            /* Initializing native localStorage right now to be able to check its support on class instanciation */
            this.prefix = '';
            if (userPrefix) {
                this.prefix = userPrefix + "_";
            }
        }
        Object.defineProperty(LocalStorageDatabase.prototype, "size", {
            get: /**
             * @return {?}
             */ function () {
                return rxjs.of(localStorage.length);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Gets an item value in local storage
         * @param key The item's key
         * @returns The item's value if the key exists, null otherwise, wrapped in an RxJS Observable
         */
        /**
         * Gets an item value in local storage
         * @template T
         * @param {?} key The item's key
         * @return {?} The item's value if the key exists, null otherwise, wrapped in an RxJS Observable
         */
        LocalStorageDatabase.prototype.getItem = /**
         * Gets an item value in local storage
         * @template T
         * @param {?} key The item's key
         * @return {?} The item's value if the key exists, null otherwise, wrapped in an RxJS Observable
         */
            function (key) {
                /** @type {?} */
                var unparsedData = localStorage.getItem("" + this.prefix + key);
                /** @type {?} */
                var parsedData = null;
                if (unparsedData != null) {
                    try {
                        parsedData = JSON.parse(unparsedData);
                    }
                    catch (error) {
                        return rxjs.throwError(new Error("Invalid data in localStorage."));
                    }
                }
                return rxjs.of(parsedData);
            };
        /**
         * Sets an item in local storage
         * @param key The item's key
         * @param data The item's value, must NOT be null or undefined
         * @returns An RxJS Observable to wait the end of the operation
         */
        /**
         * Sets an item in local storage
         * @param {?} key The item's key
         * @param {?} data The item's value, must NOT be null or undefined
         * @return {?} An RxJS Observable to wait the end of the operation
         */
        LocalStorageDatabase.prototype.setItem = /**
         * Sets an item in local storage
         * @param {?} key The item's key
         * @param {?} data The item's value, must NOT be null or undefined
         * @return {?} An RxJS Observable to wait the end of the operation
         */
            function (key, data) {
                /* Storing undefined in localStorage would then throw when getting and parsing the value */
                if (data !== undefined) {
                    localStorage.setItem("" + this.prefix + key, JSON.stringify(data));
                }
                return rxjs.of(true);
            };
        /**
         * Deletes an item in local storage
         * @param key The item's key
         * @returns An RxJS Observable to wait the end of the operation
         */
        /**
         * Deletes an item in local storage
         * @param {?} key The item's key
         * @return {?} An RxJS Observable to wait the end of the operation
         */
        LocalStorageDatabase.prototype.removeItem = /**
         * Deletes an item in local storage
         * @param {?} key The item's key
         * @return {?} An RxJS Observable to wait the end of the operation
         */
            function (key) {
                localStorage.removeItem("" + this.prefix + key);
                return rxjs.of(true);
            };
        /**
         * Deletes all items from local storage
         * @returns An RxJS Observable to wait the end of the operation
         */
        /**
         * Deletes all items from local storage
         * @return {?} An RxJS Observable to wait the end of the operation
         */
        LocalStorageDatabase.prototype.clear = /**
         * Deletes all items from local storage
         * @return {?} An RxJS Observable to wait the end of the operation
         */
            function () {
                localStorage.clear();
                return rxjs.of(true);
            };
        /**
         * @return {?}
         */
        LocalStorageDatabase.prototype.keys = /**
         * @return {?}
         */
            function () {
                /** @type {?} */
                var keys = [];
                for (var index = 0; index < localStorage.length; index += 1) {
                    keys.push(( /** @type {?} */(this.getKey(index))));
                }
                return rxjs.of(keys);
            };
        /**
         * @param {?} key
         * @return {?}
         */
        LocalStorageDatabase.prototype.has = /**
         * @param {?} key
         * @return {?}
         */
            function (key) {
                for (var index = 0; index < localStorage.length; index += 1) {
                    if (key === this.getKey(index)) {
                        return rxjs.of(true);
                    }
                }
                return rxjs.of(false);
            };
        /**
         * @protected
         * @param {?} index
         * @return {?}
         */
        LocalStorageDatabase.prototype.getKey = /**
         * @protected
         * @param {?} index
         * @return {?}
         */
            function (index) {
                /** @type {?} */
                var prefixedKey = localStorage.key(index);
                if (prefixedKey !== null) {
                    return (this.prefix === '') ? prefixedKey : prefixedKey.substr(this.prefix.length);
                }
                return null;
            };
        LocalStorageDatabase.decorators = [
            { type: i0.Injectable, args: [{
                        providedIn: 'root'
                    },] }
        ];
        /** @nocollapse */
        LocalStorageDatabase.ctorParameters = function () {
            return [
                { type: undefined, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [LOCAL_STORAGE_PREFIX,] }] }
            ];
        };
        /** @nocollapse */ LocalStorageDatabase.ngInjectableDef = i0.defineInjectable({ factory: function LocalStorageDatabase_Factory() { return new LocalStorageDatabase(i0.inject(LOCAL_STORAGE_PREFIX, 8)); }, token: LocalStorageDatabase, providedIn: "root" });
        return LocalStorageDatabase;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var IndexedDBDatabase = /** @class */ (function () {
        /**
         * Connects to IndexedDB
         */
        function IndexedDBDatabase(prefix) {
            if (prefix === void 0) {
                prefix = null;
            }
            this.prefix = prefix;
            /**
             * IndexedDB database name for local storage
             */
            this.dbName = 'ngStorage';
            /**
             * IndexedDB object store name for local storage
             */
            this.objectStoreName = 'localStorage';
            /**
             * IndexedDB key path name for local storage (where an item's key will be stored)
             */
            this.keyPath = 'key';
            /**
             * IndexedDB data path name for local storage (where items' value will be stored)
             */
            this.dataPath = 'value';
            /**
             * IndexedDB is available but failing in some scenarios (Firefox private mode, Safari cross-origin iframes),
             * so a fallback can be needed.
             */
            this.fallback = null;
            if (prefix) {
                this.dbName = prefix + "_" + this.dbName;
            }
            /* Creating the RxJS ReplaySubject */
            this.database = new rxjs.ReplaySubject();
            /* Connecting to IndexedDB */
            this.connect(prefix);
        }
        Object.defineProperty(IndexedDBDatabase.prototype, "size", {
            get: /**
             * @return {?}
             */ function () {
                var _this = this;
                /* Fallback storage if set */
                if (this.fallback) {
                    return this.fallback.size;
                }
                return this.transaction('readonly').pipe(operators.mergeMap(function (transaction) {
                    /* Deleting the item in local storage */
                    /** @type {?} */
                    var request = transaction.count();
                    /** @type {?} */
                    var success = (( /** @type {?} */(rxjs.fromEvent(request, 'success')))).pipe(operators.map(function (event) { return ( /** @type {?} */((( /** @type {?} */(event.target))).result)); }));
                    /* Merging success and errors events and autoclosing the observable */
                    return (( /** @type {?} */(rxjs.race(success, _this.toErrorObservable(request, "length")))));
                }), operators.first());
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Gets an item value in local storage
         * @param key The item's key
         * @returns The item's value if the key exists, null otherwise, wrapped in an RxJS Observable
         */
        /**
         * Gets an item value in local storage
         * @template T
         * @param {?} key The item's key
         * @return {?} The item's value if the key exists, null otherwise, wrapped in an RxJS Observable
         */
        IndexedDBDatabase.prototype.getItem = /**
         * Gets an item value in local storage
         * @template T
         * @param {?} key The item's key
         * @return {?} The item's value if the key exists, null otherwise, wrapped in an RxJS Observable
         */
            function (key) {
                var _this = this;
                /* Fallback storage if set */
                if (this.fallback) {
                    return this.fallback.getItem(key);
                }
                /* Opening a trasaction and requesting the item in local storage */
                return this.transaction().pipe(operators.map(function (transaction) { return transaction.get(key); }), operators.mergeMap(function (request) {
                    /* Listening to the success event, and passing the item value if found, null otherwise */
                    /** @type {?} */
                    var success = (( /** @type {?} */(rxjs.fromEvent(request, 'success')))).pipe(operators.map(function (event) { return (( /** @type {?} */(event.target))).result; }), operators.map(function (result) {
                        if ((result != null) && (typeof result === 'object') && (_this.dataPath in result) && (result[_this.dataPath] != null)) {
                            return (( /** @type {?} */(result[_this.dataPath])));
                        }
                        else if (result != null) {
                            return ( /** @type {?} */(result));
                        }
                        return null;
                    }));
                    /* Merging success and errors events and autoclosing the observable */
                    return (rxjs.race(success, _this.toErrorObservable(request, "getter")));
                }), operators.first());
            };
        /**
         * Sets an item in local storage
         * @param key The item's key
         * @param data The item's value, must NOT be null or undefined
         * @returns An RxJS Observable to wait the end of the operation
         */
        /**
         * Sets an item in local storage
         * @param {?} key The item's key
         * @param {?} data The item's value, must NOT be null or undefined
         * @return {?} An RxJS Observable to wait the end of the operation
         */
        IndexedDBDatabase.prototype.setItem = /**
         * Sets an item in local storage
         * @param {?} key The item's key
         * @param {?} data The item's value, must NOT be null or undefined
         * @return {?} An RxJS Observable to wait the end of the operation
         */
            function (key, data) {
                var _this = this;
                /* Fallback storage if set */
                if (this.fallback) {
                    return this.fallback.setItem(key, data);
                }
                /* Storing null is not correctly supported by IndexedDB and unnecessary here */
                if (data == null) {
                    return rxjs.of(true);
                }
                /* Transaction must be the same for read and write, to avoid concurrency issues */
                /** @type {?} */
                var transaction$ = this.transaction('readwrite');
                /** @type {?} */
                var transaction;
                /* Opening a transaction */
                return transaction$.pipe(operators.tap(function (value) {
                    transaction = value;
                }), 
                /* Check if the key already exists or not
                 * `getKey()` is only available in indexedDb v2 (Chrome >= 58)
                 * In older browsers, the value is checked instead, but it could lead to an exception
                 * if `undefined` was stored outside of this lib (e.g. directly with the native `indexedDb` API)
                 */
                operators.map(function () { return ('getKey' in transaction) ? transaction.getKey(key) : (( /** @type {?} */(transaction))).get(key); }), operators.mergeMap(function (request) {
                    /* Listening to the success event, and passing the item value if found, null otherwise */
                    /** @type {?} */
                    var success = (( /** @type {?} */(rxjs.fromEvent(request, 'success')))).pipe(operators.map(function (event) { return ( /** @type {?} */((( /** @type {?} */(event.target))).result)); }));
                    /* Merging success and errors events and autoclosing the observable */
                    return (rxjs.race(success, _this.toErrorObservable(request, "setter")));
                }), operators.mergeMap(function (existingEntry) {
                    var _a, _b;
                    /* Adding or updating local storage, based on previous checking */
                    /** @type {?} */
                    var request = (existingEntry === undefined) ?
                        transaction.add((_a = {}, _a[_this.dataPath] = data, _a), key) :
                        transaction.put((_b = {}, _b[_this.dataPath] = data, _b), key);
                    /* Merging success (passing true) and error events and autoclosing the observable */
                    return (rxjs.race(_this.toSuccessObservable(request), _this.toErrorObservable(request, "setter")));
                }), operators.first());
            };
        /**
         * Deletes an item in local storage
         * @param key The item's key
         * @returns An RxJS Observable to wait the end of the operation
         */
        /**
         * Deletes an item in local storage
         * @param {?} key The item's key
         * @return {?} An RxJS Observable to wait the end of the operation
         */
        IndexedDBDatabase.prototype.removeItem = /**
         * Deletes an item in local storage
         * @param {?} key The item's key
         * @return {?} An RxJS Observable to wait the end of the operation
         */
            function (key) {
                var _this = this;
                /* Fallback storage if set */
                if (this.fallback) {
                    return this.fallback.removeItem(key);
                }
                /* Opening a transaction and checking if the item exists in local storage */
                return this.getItem(key).pipe(operators.mergeMap(function (data) {
                    /* If the item exists in local storage */
                    if (data != null) {
                        /* Opening a transaction */
                        return _this.transaction('readwrite').pipe(operators.mergeMap(function (transaction) {
                            /* Deleting the item in local storage */
                            /** @type {?} */
                            var request = transaction.delete(key);
                            /* Merging success (passing true) and error events and autoclosing the observable */
                            return (rxjs.race(_this.toSuccessObservable(request), _this.toErrorObservable(request, "remover")));
                        }));
                    }
                    /* Passing true if the item does not exist in local storage */
                    return rxjs.of(true);
                }), operators.first());
            };
        /**
         * Deletes all items from local storage
         * @returns An RxJS Observable to wait the end of the operation
         */
        /**
         * Deletes all items from local storage
         * @return {?} An RxJS Observable to wait the end of the operation
         */
        IndexedDBDatabase.prototype.clear = /**
         * Deletes all items from local storage
         * @return {?} An RxJS Observable to wait the end of the operation
         */
            function () {
                var _this = this;
                /* Fallback storage if set */
                if (this.fallback) {
                    return this.fallback.clear();
                }
                /* Opening a transaction */
                return this.transaction('readwrite').pipe(operators.mergeMap(function (transaction) {
                    /* Deleting all items from local storage */
                    /** @type {?} */
                    var request = transaction.clear();
                    /* Merging success (passing true) and error events and autoclosing the observable */
                    return (rxjs.race(_this.toSuccessObservable(request), _this.toErrorObservable(request, "clearer")));
                }), operators.first());
            };
        /**
         * @return {?}
         */
        IndexedDBDatabase.prototype.keys = /**
         * @return {?}
         */
            function () {
                var _this = this;
                /* Fallback storage if set */
                if (this.fallback) {
                    return this.fallback.keys();
                }
                return this.transaction('readonly').pipe(operators.mergeMap(function (transaction) {
                    if ('getAllKeys' in transaction) {
                        /* Deleting the item in local storage */
                        /** @type {?} */
                        var request = transaction.getAllKeys();
                        /** @type {?} */
                        var success = (( /** @type {?} */(rxjs.fromEvent(request, 'success')))).pipe(operators.map(function (event) { return ( /** @type {?} */((( /** @type {?} */(event.target))).result)); }));
                        /* Merging success and errors events and autoclosing the observable */
                        return (rxjs.race(success, _this.toErrorObservable(request, "keys")));
                    }
                    else {
                        /* `getAllKeys()` is from IndexedDB v2.0 standard, which is not supported in IE/Edge */
                        /** @type {?} */
                        var request = (( /** @type {?} */(transaction))).openCursor();
                        /** @type {?} */
                        var keys_1 = [];
                        /** @type {?} */
                        var success = rxjs.fromEvent(request, 'success').pipe(operators.map(function (event) { return ( /** @type {?} */((( /** @type {?} */(event.target))).result)); }), operators.tap(function (cursor) {
                            if (cursor) {
                                keys_1.push(( /** @type {?} */(cursor.key)));
                                cursor.continue();
                            }
                        }), operators.filter(function (cursor) { return !cursor; }), operators.map(function () { return keys_1; }));
                        /* Merging success and errors events and autoclosing the observable */
                        return (rxjs.race(success, _this.toErrorObservable(request, "keys")));
                    }
                }), operators.first());
            };
        /**
         * @param {?} key
         * @return {?}
         */
        IndexedDBDatabase.prototype.has = /**
         * @param {?} key
         * @return {?}
         */
            function (key) {
                var _this = this;
                /* Fallback storage if set */
                if (this.fallback) {
                    return this.fallback.has(key);
                }
                return this.transaction('readonly').pipe(
                /* `getKey()` is from IndexedDB v2.0 standard, which is not supported in IE/Edge */
                operators.map(function (transaction) { return ('getKey' in transaction) ? transaction.getKey(key) : (( /** @type {?} */(transaction))).get(key); }), operators.mergeMap(function (request) {
                    /* Listening to the success event, and passing the item value if found, null otherwise */
                    /** @type {?} */
                    var success = (( /** @type {?} */(rxjs.fromEvent(request, 'success')))).pipe(operators.map(function (event) { return (( /** @type {?} */(event.target))).result; }), operators.map(function (result) { return (result !== undefined) ? true : false; }));
                    /* Merging success and errors events and autoclosing the observable */
                    return (rxjs.race(success, _this.toErrorObservable(request, "has")));
                }), operators.first());
            };
        /**
         * Connects to IndexedDB and creates the object store on first time
         */
        /**
         * Connects to IndexedDB and creates the object store on first time
         * @protected
         * @param {?=} prefix
         * @return {?}
         */
        IndexedDBDatabase.prototype.connect = /**
         * Connects to IndexedDB and creates the object store on first time
         * @protected
         * @param {?=} prefix
         * @return {?}
         */
            function (prefix) {
                var _this = this;
                if (prefix === void 0) {
                    prefix = null;
                }
                /** @type {?} */
                var request;
                /* Connecting to IndexedDB */
                try {
                    request = indexedDB.open(this.dbName);
                }
                catch (error) {
                    /* Fallback storage if IndexedDb connection is failing */
                    this.setFallback(prefix);
                    return;
                }
                /* Listening the event fired on first connection, creating the object store for local storage */
                (( /** @type {?} */(rxjs.fromEvent(request, 'upgradeneeded'))))
                    .pipe(operators.first())
                    .subscribe(function (event) {
                    /* Getting the database connection */
                    /** @type {?} */
                    var database = ( /** @type {?} */((( /** @type {?} */(event.target))).result));
                    /* Checking if the object store already exists, to avoid error */
                    if (!database.objectStoreNames.contains(_this.objectStoreName)) {
                        /* Creating the object store for local storage */
                        database.createObjectStore(_this.objectStoreName);
                    }
                });
                /* Listening the success event and converting to an RxJS Observable */
                /** @type {?} */
                var success = ( /** @type {?} */(rxjs.fromEvent(request, 'success')));
                /* Merging success and errors events */
                (( /** @type {?} */(rxjs.race(success, this.toErrorObservable(request, "connection")))))
                    .pipe(operators.first())
                    .subscribe(function (event) {
                    /* Storing the database connection for further access */
                    _this.database.next(( /** @type {?} */((( /** @type {?} */(event.target))).result)));
                }, function () {
                    /* Fallback storage if IndexedDb connection is failing */
                    _this.setFallback(prefix);
                });
            };
        /**
         * Opens an IndexedDB transaction and gets the local storage object store
         * @param mode Default to 'readonly' for read operations, or 'readwrite' for write operations
         * @returns An IndexedDB transaction object store, wrapped in an RxJS Observable
         */
        /**
         * Opens an IndexedDB transaction and gets the local storage object store
         * @protected
         * @param {?=} mode Default to 'readonly' for read operations, or 'readwrite' for write operations
         * @return {?} An IndexedDB transaction object store, wrapped in an RxJS Observable
         */
        IndexedDBDatabase.prototype.transaction = /**
         * Opens an IndexedDB transaction and gets the local storage object store
         * @protected
         * @param {?=} mode Default to 'readonly' for read operations, or 'readwrite' for write operations
         * @return {?} An IndexedDB transaction object store, wrapped in an RxJS Observable
         */
            function (mode) {
                var _this = this;
                if (mode === void 0) {
                    mode = 'readonly';
                }
                /* From the IndexedDB connection, opening a transaction and getting the local storage objet store */
                return this.database
                    .pipe(operators.map(function (database) { return database.transaction([_this.objectStoreName], mode).objectStore(_this.objectStoreName); }));
            };
        /**
         * Transforms a IndexedDB success event in an RxJS Observable
         * @param request The request to listen
         * @returns A RxJS Observable with true value
         */
        /**
         * Transforms a IndexedDB success event in an RxJS Observable
         * @protected
         * @param {?} request The request to listen
         * @return {?} A RxJS Observable with true value
         */
        IndexedDBDatabase.prototype.toSuccessObservable = /**
         * Transforms a IndexedDB success event in an RxJS Observable
         * @protected
         * @param {?} request The request to listen
         * @return {?} A RxJS Observable with true value
         */
            function (request) {
                /* Transforming a IndexedDB success event in an RxJS Observable with true value */
                return (( /** @type {?} */(rxjs.fromEvent(request, 'success'))))
                    .pipe(operators.map(function () { return true; }));
            };
        /**
         * Transforms a IndexedDB error event in an RxJS ErrorObservable
         * @param request The request to listen
         * @param error Optionnal details about the error's origin
         * @returns A RxJS ErrorObservable
         */
        /**
         * Transforms a IndexedDB error event in an RxJS ErrorObservable
         * @protected
         * @param {?} request The request to listen
         * @param {?=} error Optionnal details about the error's origin
         * @return {?} A RxJS ErrorObservable
         */
        IndexedDBDatabase.prototype.toErrorObservable = /**
         * Transforms a IndexedDB error event in an RxJS ErrorObservable
         * @protected
         * @param {?} request The request to listen
         * @param {?=} error Optionnal details about the error's origin
         * @return {?} A RxJS ErrorObservable
         */
            function (request, error) {
                if (error === void 0) {
                    error = "";
                }
                /* Transforming a IndexedDB error event in an RxJS ErrorObservable */
                return (( /** @type {?} */(rxjs.fromEvent(request, 'error'))))
                    .pipe(operators.mergeMap(function () { return rxjs.throwError(new Error("IndexedDB " + error + " issue : " + (( /** @type {?} */(request.error))).message + ".")); }));
            };
        /**
         * @protected
         * @param {?} prefix
         * @return {?}
         */
        IndexedDBDatabase.prototype.setFallback = /**
         * @protected
         * @param {?} prefix
         * @return {?}
         */
            function (prefix) {
                this.fallback = new LocalStorageDatabase(prefix);
            };
        IndexedDBDatabase.decorators = [
            { type: i0.Injectable, args: [{
                        providedIn: 'root'
                    },] }
        ];
        /** @nocollapse */
        IndexedDBDatabase.ctorParameters = function () {
            return [
                { type: undefined, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [LOCAL_STORAGE_PREFIX,] }] }
            ];
        };
        /** @nocollapse */ IndexedDBDatabase.ngInjectableDef = i0.defineInjectable({ factory: function IndexedDBDatabase_Factory() { return new IndexedDBDatabase(i0.inject(LOCAL_STORAGE_PREFIX, 8)); }, token: IndexedDBDatabase, providedIn: "root" });
        return IndexedDBDatabase;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var MockLocalDatabase = /** @class */ (function () {
        function MockLocalDatabase() {
            this.localStorage = new Map();
        }
        Object.defineProperty(MockLocalDatabase.prototype, "size", {
            get: /**
             * @return {?}
             */ function () {
                return rxjs.of(this.localStorage.size);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Gets an item value in local storage
         * @param key The item's key
         * @returns The item's value if the key exists, null otherwise, wrapped in an RxJS Observable
         */
        /**
         * Gets an item value in local storage
         * @template T
         * @param {?} key The item's key
         * @return {?} The item's value if the key exists, null otherwise, wrapped in an RxJS Observable
         */
        MockLocalDatabase.prototype.getItem = /**
         * Gets an item value in local storage
         * @template T
         * @param {?} key The item's key
         * @return {?} The item's value if the key exists, null otherwise, wrapped in an RxJS Observable
         */
            function (key) {
                /** @type {?} */
                var rawData = this.localStorage.get(key);
                return rxjs.of((rawData !== undefined) ? rawData : null);
            };
        /**
         * Sets an item in local storage
         * @param key The item's key
         * @param data The item's value, must NOT be null or undefined
         * @returns An RxJS Observable to wait the end of the operation
         */
        /**
         * Sets an item in local storage
         * @param {?} key The item's key
         * @param {?} data The item's value, must NOT be null or undefined
         * @return {?} An RxJS Observable to wait the end of the operation
         */
        MockLocalDatabase.prototype.setItem = /**
         * Sets an item in local storage
         * @param {?} key The item's key
         * @param {?} data The item's value, must NOT be null or undefined
         * @return {?} An RxJS Observable to wait the end of the operation
         */
            function (key, data) {
                this.localStorage.set(key, data);
                return rxjs.of(true);
            };
        /**
         * Deletes an item in local storage
         * @param key The item's key
         * @returns An RxJS Observable to wait the end of the operation
         */
        /**
         * Deletes an item in local storage
         * @param {?} key The item's key
         * @return {?} An RxJS Observable to wait the end of the operation
         */
        MockLocalDatabase.prototype.removeItem = /**
         * Deletes an item in local storage
         * @param {?} key The item's key
         * @return {?} An RxJS Observable to wait the end of the operation
         */
            function (key) {
                this.localStorage.delete(key);
                return rxjs.of(true);
            };
        /**
         * Deletes all items from local storage
         * @returns An RxJS Observable to wait the end of the operation
         */
        /**
         * Deletes all items from local storage
         * @return {?} An RxJS Observable to wait the end of the operation
         */
        MockLocalDatabase.prototype.clear = /**
         * Deletes all items from local storage
         * @return {?} An RxJS Observable to wait the end of the operation
         */
            function () {
                this.localStorage.clear();
                return rxjs.of(true);
            };
        /**
         * @return {?}
         */
        MockLocalDatabase.prototype.keys = /**
         * @return {?}
         */
            function () {
                return rxjs.of(Array.from(this.localStorage.keys()));
            };
        /**
         * @param {?} key
         * @return {?}
         */
        MockLocalDatabase.prototype.has = /**
         * @param {?} key
         * @return {?}
         */
            function (key) {
                return rxjs.of(this.localStorage.has(key));
            };
        MockLocalDatabase.decorators = [
            { type: i0.Injectable, args: [{
                        providedIn: 'root'
                    },] }
        ];
        /** @nocollapse */ MockLocalDatabase.ngInjectableDef = i0.defineInjectable({ factory: function MockLocalDatabase_Factory() { return new MockLocalDatabase(); }, token: MockLocalDatabase, providedIn: "root" });
        return MockLocalDatabase;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} platformId
     * @param {?} prefix
     * @return {?}
     */
    function localDatabaseFactory(platformId, prefix) {
        if (common.isPlatformBrowser(platformId) && ('indexedDB' in window) && (indexedDB !== undefined) && (indexedDB !== null)) {
            /* Try with IndexedDB in modern browsers */
            return new IndexedDBDatabase(prefix);
        }
        else if (common.isPlatformBrowser(platformId) && ('localStorage' in window) && (localStorage !== undefined) && (localStorage !== null)) {
            /* Try with localStorage in old browsers (IE9) */
            return new LocalStorageDatabase(prefix);
        }
        else {
            /* Fake database for server-side rendering (Universal) */
            return new MockLocalDatabase();
        }
    }
    /**
     * @abstract
     */
    var LocalDatabase = /** @class */ (function () {
        function LocalDatabase() {
        }
        LocalDatabase.decorators = [
            { type: i0.Injectable, args: [{
                        providedIn: 'root',
                        useFactory: localDatabaseFactory,
                        deps: [
                            i0.PLATFORM_ID,
                            [new i0.Optional(), LOCAL_STORAGE_PREFIX]
                        ]
                    },] }
        ];
        /** @nocollapse */ LocalDatabase.ngInjectableDef = i0.defineInjectable({ factory: function LocalDatabase_Factory() { return localDatabaseFactory(i0.inject(i0.PLATFORM_ID), i0.inject(LOCAL_STORAGE_PREFIX, 8)); }, token: LocalDatabase, providedIn: "root" });
        return LocalDatabase;
    }());

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    function __values(o) {
        var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
        if (m)
            return m.call(o);
        return {
            next: function () {
                if (o && i >= o.length)
                    o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * \@todo Add other JSON Schema validation features
     */
    var JSONValidator = /** @class */ (function () {
        function JSONValidator() {
        }
        /**
         * Validate a JSON data against a JSON Schema
         * @param data JSON data to validate
         * @param schema Subset of JSON Schema.
         * Types are enforced to validate everything:
         * each value MUST have 'type' or 'properties' or 'items' or 'const' or 'enum'.
         * Therefore, unlike the spec, booleans are not allowed as schemas.
         * Not all validation features are supported: just follow the interface.
         * @returns If data is valid : true, if it is invalid : false, and throws if the schema is invalid
         */
        /**
         * Validate a JSON data against a JSON Schema
         * @param {?} data JSON data to validate
         * @param {?} schema Subset of JSON Schema.
         * Types are enforced to validate everything:
         * each value MUST have 'type' or 'properties' or 'items' or 'const' or 'enum'.
         * Therefore, unlike the spec, booleans are not allowed as schemas.
         * Not all validation features are supported: just follow the interface.
         * @return {?} If data is valid : true, if it is invalid : false, and throws if the schema is invalid
         */
        JSONValidator.prototype.validate = /**
         * Validate a JSON data against a JSON Schema
         * @param {?} data JSON data to validate
         * @param {?} schema Subset of JSON Schema.
         * Types are enforced to validate everything:
         * each value MUST have 'type' or 'properties' or 'items' or 'const' or 'enum'.
         * Therefore, unlike the spec, booleans are not allowed as schemas.
         * Not all validation features are supported: just follow the interface.
         * @return {?} If data is valid : true, if it is invalid : false, and throws if the schema is invalid
         */
            function (data, schema) {
                /** @todo When TS 2.8, explore if this is possible with conditional types */
                if (((!(schema.hasOwnProperty('const') && schema.const !== undefined)
                    && !(schema.hasOwnProperty('enum') && schema.enum != null) && !(schema.hasOwnProperty('type') && schema.type != null))
                    || schema.type === 'array' || schema.type === 'object')
                    && !(schema.hasOwnProperty('properties') && schema.properties != null) && !(schema.hasOwnProperty('items') && schema.items != null)) {
                    throw new Error("Each value must have a 'type' or 'properties' or 'items' or 'const' or 'enum', to enforce strict types.");
                }
                if (schema.hasOwnProperty('const') && schema.const !== undefined && (data !== schema.const)) {
                    return false;
                }
                if (!this.validateEnum(data, schema)) {
                    return false;
                }
                if (!this.validateType(data, schema)) {
                    return false;
                }
                if (!this.validateItems(data, schema)) {
                    return false;
                }
                if (!this.validateProperties(data, schema)) {
                    return false;
                }
                if (!this.validateRequired(data, schema)) {
                    return false;
                }
                return true;
            };
        /**
         * @protected
         * @param {?} value
         * @return {?}
         */
        JSONValidator.prototype.isObjectNotNull = /**
         * @protected
         * @param {?} value
         * @return {?}
         */
            function (value) {
                return (value !== null) && (typeof value === 'object');
            };
        /**
         * @protected
         * @param {?} data
         * @param {?} schema
         * @return {?}
         */
        JSONValidator.prototype.validateProperties = /**
         * @protected
         * @param {?} data
         * @param {?} schema
         * @return {?}
         */
            function (data, schema) {
                if (!schema.hasOwnProperty('properties') || (schema.properties == null)) {
                    return true;
                }
                if (!this.isObjectNotNull(data)) {
                    return false;
                }
                /**
                 * Check if the object doesn't have more properties than expected
                 * Equivalent of additionalProperties: false
                 */
                if (Object.keys(schema.properties).length < Object.keys(data).length) {
                    return false;
                }
                /* Recursively validate all properties */
                for (var property in schema.properties) {
                    if (schema.properties.hasOwnProperty(property) && data.hasOwnProperty(property)) {
                        if (!this.validate(data[property], schema.properties[property])) {
                            return false;
                        }
                    }
                }
                return true;
            };
        /**
         * @protected
         * @param {?} data
         * @param {?} schema
         * @return {?}
         */
        JSONValidator.prototype.validateRequired = /**
         * @protected
         * @param {?} data
         * @param {?} schema
         * @return {?}
         */
            function (data, schema) {
                var e_1, _a;
                if (!schema.hasOwnProperty('required') || (schema.required == null)) {
                    return true;
                }
                if (!this.isObjectNotNull(data)) {
                    return false;
                }
                try {
                    for (var _b = __values(schema.required), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var requiredProp = _c.value;
                        /* Checks if the property is present in the schema 'properties' */
                        if (!schema.properties || !schema.properties.hasOwnProperty(requiredProp)) {
                            throw new Error("'required' properties must be described in 'properties' too.");
                        }
                        /* Checks if the property is present in the data */
                        if (!data.hasOwnProperty(requiredProp)) {
                            return false;
                        }
                    }
                }
                catch (e_1_1) {
                    e_1 = { error: e_1_1 };
                }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return))
                            _a.call(_b);
                    }
                    finally {
                        if (e_1)
                            throw e_1.error;
                    }
                }
                return true;
            };
        /**
         * @protected
         * @param {?} data
         * @param {?} schema
         * @return {?}
         */
        JSONValidator.prototype.validateEnum = /**
         * @protected
         * @param {?} data
         * @param {?} schema
         * @return {?}
         */
            function (data, schema) {
                if (!schema.hasOwnProperty('enum') || (schema.enum == null)) {
                    return true;
                }
                /** @todo Move to ES2016 .includes() ? */
                return (schema.enum.indexOf(data) !== -1);
            };
        /**
         * @protected
         * @param {?} data
         * @param {?} schema
         * @return {?}
         */
        JSONValidator.prototype.validateType = /**
         * @protected
         * @param {?} data
         * @param {?} schema
         * @return {?}
         */
            function (data, schema) {
                if (!schema.hasOwnProperty('type') || (schema.type == null)) {
                    return true;
                }
                switch (schema.type) {
                    case 'null':
                        return data === null;
                    case 'string':
                        return this.validateString(data, schema);
                    case 'number':
                    case 'integer':
                        return this.validateNumber(data, schema);
                    case 'boolean':
                        return typeof data === 'boolean';
                    case 'object':
                        return typeof data === 'object';
                    case 'array':
                        return Array.isArray(data);
                }
                return true;
            };
        /**
         * @protected
         * @param {?} data
         * @param {?} schema
         * @return {?}
         */
        JSONValidator.prototype.validateItems = /**
         * @protected
         * @param {?} data
         * @param {?} schema
         * @return {?}
         */
            function (data, schema) {
                var e_2, _a;
                if (!schema.hasOwnProperty('items') || (schema.items == null)) {
                    return true;
                }
                if (!Array.isArray(data)) {
                    return false;
                }
                if (schema.hasOwnProperty('maxItems') && (schema.maxItems != null)) {
                    if (!Number.isInteger(schema.maxItems) || schema.maxItems < 0) {
                        throw new Error("'maxItems' must be a non-negative integer.");
                    }
                    if (data.length > schema.maxItems) {
                        return false;
                    }
                }
                if (schema.hasOwnProperty('minItems') && (schema.minItems != null)) {
                    if (!Number.isInteger(schema.minItems) || schema.minItems < 0) {
                        throw new Error("'minItems' must be a non-negative integer.");
                    }
                    if (data.length < schema.minItems) {
                        return false;
                    }
                }
                if (schema.hasOwnProperty('uniqueItems') && (schema.uniqueItems != null)) {
                    if (schema.uniqueItems) {
                        /** @type {?} */
                        var dataSet = new Set(data);
                        if (data.length !== dataSet.size) {
                            return false;
                        }
                    }
                }
                if (Array.isArray(schema.items)) {
                    return this.validateItemsList(data, schema);
                }
                try {
                    for (var data_1 = __values(data), data_1_1 = data_1.next(); !data_1_1.done; data_1_1 = data_1.next()) {
                        var value = data_1_1.value;
                        if (!this.validate(value, schema.items)) {
                            return false;
                        }
                    }
                }
                catch (e_2_1) {
                    e_2 = { error: e_2_1 };
                }
                finally {
                    try {
                        if (data_1_1 && !data_1_1.done && (_a = data_1.return))
                            _a.call(data_1);
                    }
                    finally {
                        if (e_2)
                            throw e_2.error;
                    }
                }
                return true;
            };
        /**
         * @protected
         * @param {?} data
         * @param {?} schema
         * @return {?}
         */
        JSONValidator.prototype.validateItemsList = /**
         * @protected
         * @param {?} data
         * @param {?} schema
         * @return {?}
         */
            function (data, schema) {
                /** @type {?} */
                var items = ( /** @type {?} */(schema.items));
                if (data.length !== items.length) {
                    return false;
                }
                for (var i = 0; i < items.length; i += 1) {
                    if (!this.validate(data[i], items[i])) {
                        return false;
                    }
                }
                return true;
            };
        /**
         * @protected
         * @param {?} data
         * @param {?} schema
         * @return {?}
         */
        JSONValidator.prototype.validateString = /**
         * @protected
         * @param {?} data
         * @param {?} schema
         * @return {?}
         */
            function (data, schema) {
                if (typeof data !== 'string') {
                    return false;
                }
                if (schema.hasOwnProperty('maxLength') && (schema.maxLength != null)) {
                    if (!Number.isInteger(schema.maxLength) || schema.maxLength < 0) {
                        throw new Error("'maxLength' must be a non-negative integer.");
                    }
                    if (data.length > schema.maxLength) {
                        return false;
                    }
                }
                if (schema.hasOwnProperty('minLength') && (schema.minLength != null)) {
                    if (!Number.isInteger(schema.minLength) || schema.minLength < 0) {
                        throw new Error("'minLength' must be a non-negative integer.");
                    }
                    if (data.length < schema.minLength) {
                        return false;
                    }
                }
                if (schema.hasOwnProperty('pattern') && (schema.pattern != null)) {
                    /** @type {?} */
                    var regularExpression = new RegExp(schema.pattern);
                    if (!regularExpression.test(data)) {
                        return false;
                    }
                }
                return true;
            };
        /**
         * @protected
         * @param {?} data
         * @param {?} schema
         * @return {?}
         */
        JSONValidator.prototype.validateNumber = /**
         * @protected
         * @param {?} data
         * @param {?} schema
         * @return {?}
         */
            function (data, schema) {
                if (typeof data !== 'number') {
                    return false;
                }
                if ((schema.type === 'integer') && !Number.isInteger(data)) {
                    return false;
                }
                if (schema.hasOwnProperty('multipleOf') && (schema.multipleOf != null)) {
                    if (schema.multipleOf <= 0) {
                        throw new Error("'multipleOf' must be a number strictly greater than 0.");
                    }
                    if (!Number.isInteger(data / schema.multipleOf)) {
                        return false;
                    }
                }
                if (schema.hasOwnProperty('maximum') && (schema.maximum != null)) {
                    if (data > schema.maximum) {
                        return false;
                    }
                }
                if (schema.hasOwnProperty('exclusiveMaximum') && (schema.exclusiveMaximum != null)) {
                    if (data >= schema.exclusiveMaximum) {
                        return false;
                    }
                }
                if (schema.hasOwnProperty('minimum') && (schema.minimum != null)) {
                    if (data < schema.minimum) {
                        return false;
                    }
                }
                if (schema.hasOwnProperty('exclusiveMinimum') && (schema.exclusiveMinimum != null)) {
                    if (data <= schema.exclusiveMinimum) {
                        return false;
                    }
                }
                return true;
            };
        JSONValidator.decorators = [
            { type: i0.Injectable, args: [{
                        providedIn: 'root'
                    },] }
        ];
        /** @nocollapse */ JSONValidator.ngInjectableDef = i0.defineInjectable({ factory: function JSONValidator_Factory() { return new JSONValidator(); }, token: JSONValidator, providedIn: "root" });
        return JSONValidator;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var LocalStorage = /** @class */ (function () {
        function LocalStorage(database, jsonValidator) {
            this.database = database;
            this.jsonValidator = jsonValidator;
            this.getItemOptionsDefault = {
                schema: null
            };
        }
        Object.defineProperty(LocalStorage.prototype, "size", {
            /**
             * Number of items in the storage
             */
            get: /**
             * Number of items in the storage
             * @return {?}
             */ function () {
                return this.database.size;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @template T
         * @param {?} key
         * @param {?=} options
         * @return {?}
         */
        LocalStorage.prototype.getItem = /**
         * @template T
         * @param {?} key
         * @param {?=} options
         * @return {?}
         */
            function (key, options) {
                var _this = this;
                if (options === void 0) {
                    options = this.getItemOptionsDefault;
                }
                return this.database.getItem(key).pipe(
                /* Validate data upon a json schema if requested */
                operators.mergeMap(function (data) {
                    if (data === null) {
                        return rxjs.of(null);
                    }
                    else if (options.schema) {
                        /** @type {?} */
                        var validation = true;
                        try {
                            validation = _this.jsonValidator.validate(data, options.schema);
                        }
                        catch (error) {
                            return rxjs.throwError(error);
                        }
                        if (!validation) {
                            return rxjs.throwError(new Error("JSON invalid"));
                        }
                    }
                    return rxjs.of(( /** @type {?} */(data)));
                }));
            };
        /**
         * Gets an item value in local storage WITHOUT any validation.
         * It is a convenience method for development only: do NOT use it in production code,
         * as it can cause security issues and errors and may be removed in future versions.
         * Use the normal .getItem() method instead.
         * @ignore
         * @deprecated
         * @param key The item's key
         * @returns The item's value if the key exists, null otherwise, wrapped in an RxJS Observable
         */
        /**
         * Gets an item value in local storage WITHOUT any validation.
         * It is a convenience method for development only: do NOT use it in production code,
         * as it can cause security issues and errors and may be removed in future versions.
         * Use the normal .getItem() method instead.
         * @ignore
         * @deprecated
         * @template T
         * @param {?} key The item's key
         * @return {?} The item's value if the key exists, null otherwise, wrapped in an RxJS Observable
         */
        LocalStorage.prototype.getUnsafeItem = /**
         * Gets an item value in local storage WITHOUT any validation.
         * It is a convenience method for development only: do NOT use it in production code,
         * as it can cause security issues and errors and may be removed in future versions.
         * Use the normal .getItem() method instead.
         * @ignore
         * @deprecated
         * @template T
         * @param {?} key The item's key
         * @return {?} The item's value if the key exists, null otherwise, wrapped in an RxJS Observable
         */
            function (key) {
                return this.database.getItem(key);
            };
        /**
         * Sets an item in local storage
         * @param key The item's key
         * @param data The item's value, must NOT be null or undefined
         * @returns An RxJS Observable to wait the end of the operation
         */
        /**
         * Sets an item in local storage
         * @param {?} key The item's key
         * @param {?} data The item's value, must NOT be null or undefined
         * @return {?} An RxJS Observable to wait the end of the operation
         */
        LocalStorage.prototype.setItem = /**
         * Sets an item in local storage
         * @param {?} key The item's key
         * @param {?} data The item's value, must NOT be null or undefined
         * @return {?} An RxJS Observable to wait the end of the operation
         */
            function (key, data) {
                return this.database.setItem(key, data);
            };
        /**
         * Deletes an item in local storage
         * @param key The item's key
         * @returns An RxJS Observable to wait the end of the operation
         */
        /**
         * Deletes an item in local storage
         * @param {?} key The item's key
         * @return {?} An RxJS Observable to wait the end of the operation
         */
        LocalStorage.prototype.removeItem = /**
         * Deletes an item in local storage
         * @param {?} key The item's key
         * @return {?} An RxJS Observable to wait the end of the operation
         */
            function (key) {
                return this.database.removeItem(key);
            };
        /**
         * Deletes all items from local storage
         * @returns An RxJS Observable to wait the end of the operation
         */
        /**
         * Deletes all items from local storage
         * @return {?} An RxJS Observable to wait the end of the operation
         */
        LocalStorage.prototype.clear = /**
         * Deletes all items from local storage
         * @return {?} An RxJS Observable to wait the end of the operation
         */
            function () {
                return this.database.clear();
            };
        /**
         * Get all keys stored in local storage
         * @returns A RxJS Observable returning an array of the indexes
         */
        /**
         * Get all keys stored in local storage
         * @return {?} A RxJS Observable returning an array of the indexes
         */
        LocalStorage.prototype.keys = /**
         * Get all keys stored in local storage
         * @return {?} A RxJS Observable returning an array of the indexes
         */
            function () {
                return this.database.keys();
            };
        /**
         * Tells if a key exists in storage
         * @returns A RxJS Observable telling if the key exists
         */
        /**
         * Tells if a key exists in storage
         * @param {?} key
         * @return {?} A RxJS Observable telling if the key exists
         */
        LocalStorage.prototype.has = /**
         * Tells if a key exists in storage
         * @param {?} key
         * @return {?} A RxJS Observable telling if the key exists
         */
            function (key) {
                return this.database.has(key);
            };
        /**
         * Sets an item in local storage, and auto-subscribes
         * @param key The item's key
         * @param data The item's value, must NOT be null or undefined
         */
        /**
         * Sets an item in local storage, and auto-subscribes
         * @param {?} key The item's key
         * @param {?} data The item's value, must NOT be null or undefined
         * @return {?}
         */
        LocalStorage.prototype.setItemSubscribe = /**
         * Sets an item in local storage, and auto-subscribes
         * @param {?} key The item's key
         * @param {?} data The item's value, must NOT be null or undefined
         * @return {?}
         */
            function (key, data) {
                this.setItem(key, data).subscribe(function () { }, function () { });
            };
        /**
         * Deletes an item in local storage, and auto-subscribes
         * @param key The item's key
         */
        /**
         * Deletes an item in local storage, and auto-subscribes
         * @param {?} key The item's key
         * @return {?}
         */
        LocalStorage.prototype.removeItemSubscribe = /**
         * Deletes an item in local storage, and auto-subscribes
         * @param {?} key The item's key
         * @return {?}
         */
            function (key) {
                this.removeItem(key).subscribe(function () { }, function () { });
            };
        /** Deletes all items from local storage, and auto-subscribes */
        /**
         * Deletes all items from local storage, and auto-subscribes
         * @return {?}
         */
        LocalStorage.prototype.clearSubscribe = /**
         * Deletes all items from local storage, and auto-subscribes
         * @return {?}
         */
            function () {
                this.clear().subscribe(function () { }, function () { });
            };
        LocalStorage.decorators = [
            { type: i0.Injectable, args: [{
                        providedIn: 'root'
                    },] }
        ];
        /** @nocollapse */
        LocalStorage.ctorParameters = function () {
            return [
                { type: LocalDatabase },
                { type: JSONValidator }
            ];
        };
        /** @nocollapse */ LocalStorage.ngInjectableDef = i0.defineInjectable({ factory: function LocalStorage_Factory() { return new LocalStorage(i0.inject(LocalDatabase), i0.inject(JSONValidator)); }, token: LocalStorage, providedIn: "root" });
        return LocalStorage;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    exports.LocalDatabase = LocalDatabase;
    exports.IndexedDBDatabase = IndexedDBDatabase;
    exports.LocalStorageDatabase = LocalStorageDatabase;
    exports.MockLocalDatabase = MockLocalDatabase;
    exports.JSONValidator = JSONValidator;
    exports.LocalStorage = LocalStorage;
    exports.localStorageProviders = localStorageProviders;
    exports.LOCAL_STORAGE_PREFIX = LOCAL_STORAGE_PREFIX;
    exports.a = localDatabaseFactory;

    Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=ngx-pwa-local-storage.umd.js.map